<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: db.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: db.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Helper functions for the MongoDB Database. */
/* This can be refactored to OO style for better modularity. */

const MongoClient = require('mongodb').MongoClient;
const options = { useUnifiedTopology: true, writeConcern: { j: true } };

/** Class wrapping database operations. */
class Database {
    client = null;

    // create a connection to url and call callback()
    /**
     * Connect the database
     * @param {string} url - The url for the database
     */
    static connect(url, callback) {
        if (Database.client == null) {
            // create a mongodb client
            Database.client = new MongoClient(url, options);
            // establish a new connection
            Database.client.connect((err) => {
                if (err) {
                    // error occurred during connection
                    Database.client = null;
                    callback(err);
                } else {
                    // all done
                    callback();
                }
            });
        } else {
            // connection was established earlier. just call callback()
            callback();
        }
    }

    /**
     * Database wrapper
     * @param {string} dbName - Name of the database.
     * @returns {database} - Database for MongoDB operations.
     */
    static db(dbName) {
        return Database.client.db(dbName);
    }

    /**
     * Close the connection
     */
    static close() {
        if (Database.client) {
            Database.client.close();
            Database.client = null;
        }
    }

    /**
     * Stores a user
     * @param {User} body - JSON of a user file.
     */
    static store_user(body, next) {
        return Database.db('GrandValet').collection('Users').findOne({username: body.username})
        .then((user) => {
            if (user == null) 
            {
                let newData = {type: body.type, username: body.username, name: body.name, password: body.password, email: body.email, phone: body.phone, driverStatus: body.driverStatus};
                Database.db('GrandValet').collection('Users').insertOne(newData);
                return;
            }
            Database.db('GrandValet').collection('Users').updateOne({username: body.username}, { $set: {type: body.type, name: body.name, password: body.password, email: body.email, phone: body.phone, driverStatus: body.driverStatus}});
        });
    }

    /**
     * Reads a user
     * @param {string} username - Username of the requested user.
     * @returns {User} - JSON of the requested user file.
     */
     static read_user(username, next) {
        return Database.db('GrandValet').collection('Users').findOne({username: username})
        .then((user) => {
            if (user == null) 
            {
                //console.log("bad")
                return null;
            }
            return user;
        });
    }
    
    /**
     * Returns all currently active hubs.
     * @returns {Hub[]} - Array of JSON of currently active hubs.
     */
     static read_activeHubs(next) {
        let time = Math.floor(Date.now() / 1000);
        return Database.db('GrandValet').collection('Hubs').find({$and: [{ startTime : { $lt :  time}}, { endTime : { $gt :  time}}]}).toArray()
        .then((hubs) => {
            if (hubs == null) 
            {
                //console.log("bad")
                throw "Error in database";
            }
            return hubs;
        });
    }

    /**
     * Reads nearby hubs
     * @param {coordinates} loc - Cordinates of the center of the search.
     * @param {number} radius - Radius of the search in miles.
     * @returns {Hub[]} - Array of JSON of hubs satisfying the query.
     */
    // Radius is in miles, longitude first (this is important, as normally latitutde first)
    static read_nearbyHubs(loc, radius, next) {
        let milesToRadian = function(miles){
            let earthRadiusInMiles = 3959;
            return miles / earthRadiusInMiles;
        };
        let query = {
            "location" : {
                $geoWithin : {
                    $centerSphere : [loc, milesToRadian(radius) ]
                }
            }
        };
        return Database.db('GrandValet').collection('Hubs').find(query).toArray()
        .then((hubs) => {
            if (hubs == null) 
            {
                //console.log("bad")
                throw "Error in database";
            }
            return hubs;
        });
    }

    /**
     * Reads a hub
     * @param {number} hubId - ID of the requested hub.
     * @returns {Hub} - JSON of the requested hub.
     */
    static read_hub(hubId, next) {
        return Database.db('GrandValet').collection('Hubs').findOne({hubId: hubId})
        .then((hub) => {
            if (hub == null) 
            {
                //console.log("bad")
                return null;
            }
            return hub;
        });
    }

    /**
     * Stores a hub
     * @param {Hub} body - JSON of a hub file.
     */
     static store_hub(body, next) {
        //console.log(body);
        return Database.db('GrandValet').collection('Hubs').findOne({hubId: body.hubId})
        .then((user) => {
            if (user == null) 
            {
                //console.log(body);
                let newData = {hubId: body.hubId, description: body.description, location: body.location, startTime: body.startTime, endTime: body.endTime};
                Database.db('GrandValet').collection('Meta').updateOne({}, { $set: {maxHubId: body.hubId}});
                Database.db('GrandValet').collection('Hubs').insertOne(newData);
                return;
            }
            //console.log(body);
            Database.db('GrandValet').collection('Hubs').updateOne({hubId: body.hubId}, { $set: {hubId: body.hubId, description: body.description, location: body.location, startTime: body.startTime, endTime: body.endTime}});
        });
    }

    /**
     * Reads jobs assigned to a driver and assign jobs is within 1 hr of scheduled time.
     * @param {string} username - Username of the requested driver.
     * @returns {Job[]} - Array of JSON of jobs assigned to the driver.
     */
    // TODO: Potential problem in time zone
    // TODO: Does not return immediate update
    static read_assignedJobs(username, next) {
        let currentTime = new Date().getTime();
        let query1 = {
            $and:[
                {$or: [{ status : 1 }, { status : 6 }]},
                { scheduledTime : { $lt :  (currentTime + 3600)}}
            ]
        };
        return Database.db('GrandValet').collection('Jobs').find(query1).toArray()
        .then((jobsToBeAssigned) => {
            //console.log(jobsToBeAssigned);
            // To check available drivers
            let query2 = {
                $and:[
                    { type : 2 },
                    { driverStatus : 1 }
                ]
            };    
            
            for (let jobToBeAssigned of jobsToBeAssigned) {
                //console.log('should not be here');
                Database.db('GrandValet').collection('Users').aggregate([
                    {
                        $match: {
                            $and:[
                                { type : 2 },
                                { driverStatus : 1 }
                            ]
                        }
                    },
                    {
                        $lookup: {
                                from: "Jobs",
                                localField: "username",
                                foreignField: "driverUsername",
                                as: "driverJobs"
                            }
                    },
                    {
                       $project: {
                            username: 1,
                            numberOfJobs: { $size: "$driverJobs" }
                       }
                    }
                ]).sort( { numberOfJobs: 1 } ).toArray()
                .then((driversAvailable) => {
                    if (driversAvailable.length > 0)
                    {
                        let assignedDriver = driversAvailable[0].username;
                        Database.db('GrandValet').collection('Jobs').updateOne({jobId: jobToBeAssigned.jobId}, { $set: {driverUsername: assignedDriver}});
                    }
                })
            }
            //console.log('right');
        }).then(() => {
            return Database.db('GrandValet').collection('Jobs').find({driverUsername: username}).toArray()
            .then((jobs) => {
                if (jobs == null) 
                {
                    //console.log("bad")
                    throw "Error in database";
                }
                return jobs;
            });
        });

    }

    /**
     * Reads a job and assign jobs is within 1 hr of scheduled time.
     * @param {number} jobId - ID of the requested job.
     * @returns {Job} - JSON of the requested job.
     */
    // TODO: Potential problem in time zone
    // TODO: Does not return immediate update
    static read_job(jobId, next) {
        let currentTime = new Date().getTime();
        let query1 = {
            $and:[
                {$or: [{ status : 1 }, { status : 6 }]},
                { scheduledTime : { $lt :  (currentTime + 3600)}}
            ]
        };
        return Database.db('GrandValet').collection('Jobs').find(query1).toArray()
        .then((jobsToBeAssigned) => {
            //console.log(jobsToBeAssigned);
            // To check available drivers
            let query2 = {
                $and:[
                    { type : 2 },
                    { driverStatus : 1 }
                ]
            };    
            
            for (let jobToBeAssigned of jobsToBeAssigned) {
                //console.log('should not be here');
                Database.db('GrandValet').collection('Users').aggregate([
                    {
                        $match: {
                            $and:[
                                { type : 2 },
                                { driverStatus : 1 }
                            ]
                        }
                    },
                    {
                        $lookup: {
                                from: "Jobs",
                                localField: "username",
                                foreignField: "driverUsername",
                                as: "driverJobs"
                            }
                    },
                    {
                       $project: {
                            username: 1,
                            numberOfJobs: { $size: "$driverJobs" }
                       }
                    }
                ]).sort( { numberOfJobs: 1 } ).toArray()
                .then((driversAvailable) => {
                    if (driversAvailable.length > 0)
                    {
                        let assignedDriver = driversAvailable[0].username;
                        Database.db('GrandValet').collection('Jobs').updateOne({jobId: jobToBeAssigned.jobId}, { $set: {driverUsername: assignedDriver}});
                    }
                })
            }
            //console.log('right');
        }).then(() => {
            return Database.db('GrandValet').collection('Jobs').findOne({jobId: jobId})
            .then((job) => {
                if (job == null) 
                {
                    return null;
                }
                //console.log(job);
                return job;
            });
        });


    }

    /**
     * Stores a job
     * @param {Job} body - JSON of a job file.
     */
    static store_job(body, next) {
        //console.log(body);
        return Database.db('GrandValet').collection('Jobs').findOne({jobId: body.jobId})
        .then((job) => {
            if (job == null) 
            {
                //console.log(body);
                let newData = {type: body.type, jobId: body.jobId, scheduledTime: body.scheduledTime, status: body.status, licenceState: body.licenceState,
                    licenceNum: body.licenceNum, code: body.code, hubId: body.hubId, carLocation: body.carLocation, note: body.note,
                    driverUsername: body.driverUsername, customerUsername: body.customerUsername, advanceState: body.advanceState};
                Database.db('GrandValet').collection('Meta').updateOne({}, { $set: {maxJobId: body.JobId}});
                Database.db('GrandValet').collection('Jobs').insertOne(newData);
                return;
            }
            //console.log(body);
            Database.db('GrandValet').collection('Jobs').updateOne({jobId: body.jobId}, { $set: {type: body.type, jobId: body.jobId, scheduledTime: body.scheduledTime, status: body.status, licenceState: body.licenceState,
                licenceNum: body.licenceNum, code: body.code, hubId: body.hubId, carLocation: body.carLocation, note: body.note,
                driverUsername: body.driverUsername, customerUsername: body.customerUsername, advanceState: body.advanceState}});
        });
    }

    /**
     * Reads the currect maximum jobId
     * @returns {number} - Currect maximum jobId.
     */
    static read_maxMaxJobId(next) {
        return Database.db('GrandValet').collection('Meta').find()
        .then((meta) => {
            if (meta == null) 
            {
                //console.log("bad")
                throw "Error in database";
            }
            return meta.maxJobId;
        });
    }

    /**
     * Reads the currect maximum hubId
     * @returns {number} - Currect maximum hubId.
     */
     static read_maxMaxHubId(next) {
        return Database.db('GrandValet').collection('Meta').find()
        .then((meta) => {
            if (meta == null) 
            {
                //console.log("bad")
                throw "Error in database";
            }
            return meta.maxHubId;
        });
    }
}
// export connect(), db() and close() from the module
module.exports = {Database};
//module.exports = {grandValet};

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Database.html">Database</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Tue Nov 09 2021 21:36:17 GMT-0800 (Pacific Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
